import{config as t}from"@onflow/config";import*as n from"@onflow/types";import*as e from"@onflow/fcl";import{config as r}from"@onflow/fcl";const o={emulator:{FlowToken:"0xee82856bf20e2aa6",FungibleToken:"0x0ae53cb6e3f42a79"},testnet:{FlowToken:"0x7e60df042a9c0868",FungibleToken:"0x9a0766d93b6608b7",LockedTokens:"0x95e019a17d0e23d7",StakingProxy:"0x7aad92e5a0715d21",FUSD:"0xe223d8a629e49c68"},mainnet:{FlowToken:"0x1654653399040a61",FungibleToken:"0xf233dcee88fe0abe",LockedTokens:"0x8d0e87b65159ae63",StakingProxy:"0x62430cf28c26d095",FUSD:"0x3c5959b568896393"}},a={mainnet:"https://access-mainnet-beta.onflow.org",testnet:"https://access-testnet.onflow.org",emulator:"http://localhost:8080"},s=async()=>{const n=await(async()=>await t().get("ix.env")||"emulator")();return o[n]||o.emulator},c=async(n="emulator",e={})=>{const r=n.toLowerCase();if(!o[r])throw new Error(`Provided value "${r}" is not supported. Try "emulator", "testnet" or "mainnet". Default: "emulator"`);const{port:s,endpoint:c,limit:i}=e,u=c||("emulator"===r&&s?`http://localhost:${s}`:a[r]);await t().put("ix.env",r),i&&await t().put("ix.executionLimit",i),await t().put("accessNode.api",u)},i=t=>t.split(/\s/).map(t=>t.replace(/\s/g,"")).filter(t=>t.length>0&&"import"!==t&&"from"!==t),u=(t,n)=>{const[e,r]=n;return t[e]=r,t},l=t=>t&&0!==t.length?t.split("\n").filter(t=>t.includes("import")).map(i).reduce(u,{}):{},f=(t,n={})=>{const e=l(t),r=[];for(const t in e)!n[t]&&Object.prototype.hasOwnProperty.call(e,t)&&r.push(t);return r},d=(t=[],n="")=>{const e="Missing imports for contracts:";console.error(n?`${n} ${e}`:e,t)},p=(t,n,e="")=>{const r=f(t,n);r.length>0&&d(r,e)},m=/(\s*import\s*)([\w\d]+)(\s+from\s*)([\w\d".\\/]+)/g,w=(t,n,e=!0)=>t.replace(m,(t,r,o,a,s)=>{const c=e?o:s;return`${r}${o} from ${(n instanceof Function?n(c):n[c])||s}`}),g=["public","private","storage"],y=t=>{const[n]=t.split("");return n.toUpperCase()+t.slice(1)},x=t=>t.replace(/-/g,"_").split("_").map((t,n)=>n>0?y(t):t).join(""),h=(t,n,e)=>e?t.replace(n,"").split(e):t.replace(n,"").split(b(t)),b=t=>{switch(!0){case t.indexOf("//")>=0:return"//";case t.indexOf("/")>=0:return"/";case t.indexOf("\\")>=0:return"\\";default:return""}},v=t=>t.replace(/\s+/g," "),$="contract",S="transaction",k="script",E=t=>t.split(",").map(t=>t.replace(/\s*/g,"")).filter(t=>""!==t),F=t=>t.replace(/(\/\*[\s\S]*?\*\/)|(\/\/.*)/g,""),T=(t,n)=>{const e=F(t),r=v(e.replace(/[\n\r]/g,""));if(r){const t=new RegExp(n,"g").exec(r);if(t)return""===t[1]?[]:E(t[1])}return[]},P=t=>T(t,"(?:prepare\\s*\\(\\s*)([^\\)]*)(?:\\))"),I=t=>T(t,"(?:fun\\s+main\\s*\\(\\s*)([^\\)]*)(?:\\))"),A=t=>T(t,"(?:transaction\\s*\\(\\s*)([^\\)]*)(?:\\))"),N=t=>{const n=F(t).replace(/\r\n|\n|\r/g," "),e=/\w+\s+contract\s+(?:interface)*\s*(\w*)/g.exec(n);if(e.length<2)throw new Error("Contract Error: can't find name of the contract");return e[1]},U=t=>{const n=F(t).replace(/(resource|struct)\s+\w+\s*{[\s\S]+?}/g,""),e=/(?:access\(\w+\)|pub)\s+contract\s+(?:interface)*\s*(\w*)(\s*{[.\s\S]*init\s*\((.*?)\)[.\s\S]*})?/g.exec(n);if(e.length<2)throw new Error("Contract Error: can't find name of the contract");return{contractName:e[1],args:e[3]||""}},j=t=>{const n=F(t);if(/transaction\s*(\(\s*\))*\s*/g.test(n)){const t=P(n),e=A(n);return{type:"transaction",signers:t.length,args:e}}if(/pub\s+fun\s+main\s*/g.test(n))return{type:"script",args:I(n)};if(/\w+\s+contract\s+(\w*\s*)\w*/g.test(n)){const{contractName:t,args:e}=U(n);return{type:"contract",signers:1,args:e,contractName:t}}return{type:"unknown"}},L=t=>!t||"string"!=typeof t,M=t=>!L(t)&&(t.startsWith("Int")||t.startsWith("UInt")||t.startsWith("Word")),O=t=>{if(L(t))return!1;const n=t.replace(/\s/g,"");return n.startsWith("[")&&n.endsWith("]")},_=t=>{if(L(t))return!1;const n=t.replace(/\s/g,"");return n.startsWith("{")&&n.endsWith("}")},C=t=>O(t)||_(t);function D(){return(D=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}return t}).apply(this,arguments)}const R={ARGUMENT:"argument"},B=async t=>{const{type:n}=t,e=await r().get("ix.plugins")||{},o=e[n]||[];await r().put("ix.plugins",D({},e,{[n]:[...o,t]}))},H=async t=>{const n=(await r().get("ix.plugins")||{})[t];return!!(n&&n.length>0)&&n},q=t=>t.split(/(\w+)\s*:\s*([\w{}[\]:\s?]*)/).filter(t=>""!==t).map(t=>t.replace(/\s*/g,"")),z=t=>q(t)[1],G=t=>/{(.*)}/.exec(t)[1].split(/([^:]*):(.*)/).map(t=>t.replace(/\s/g,"")).filter(t=>t),W=t=>/\[(.*)\]/.exec(t)[1].replace(/\s+/g,""),J=(t,n,e="")=>{if(n>t){const r=`Incorrect number of arguments: found ${t} of ${n}`;console.error(e?`${e} ${r}`:r)}},K=(t="items",n,e,r="")=>{if(e!==n){const o=`Incorrect number of ${t}: found ${n} of ${e}`;console.error(r?`${r} ${o}`:o)}},Q=t=>!L(t)&&(t.includes("?")?n.Optional(n[(t=>t.slice(0,-1))(t)]):n[t]),V=t=>{if(C(t))switch(!0){case O(t):{const e=W(t);return n.Array(V(e))}case _(t):{const[e,r]=G(t),o={key:V(e),value:V(r)};return n.Dictionary(o)}default:return Q(t)}return Q(t)},X=async(t,n)=>{const r=await H(R.ARGUMENT);let o=n,a=t;if(r){let e=await(async(t,n)=>{let e=t.type,r=t.value;for(let t=0;t<n.length;t++){const{resolver:o}=n[t],a=await o(e,r);e=a.type,r=a.value}return{type:e,value:r}})({type:t,value:n},r);o=e.value,a=e.type}const s=V(a);switch(!0){case(t=>{if(L(t))return!1;let n=t.endsWith("?")?t.slice(0,-1):t;return M(n)||(t=>"String"===t)(n)||(t=>"Character"===t)(n)||(t=>"Bool"===t)(n)})(a):return e.arg(o,s);case(t=>!L(t)&&(t.startsWith("Fix64")||t.startsWith("UFix64")))(a):return null===o?e.arg(null,s):(isNaN(parseFloat(o))&&(t=>{throw new Error("Type Error: Expected proper value for fixed type")})(),e.arg(parseFloat(o).toFixed(8),s));case(t=>"Address"===t||"Address?"===t)(a):{const t=null==(c=o)?null:"0x"+(t=>null==t?null:t.replace(/^0x/,""))(c);return e.arg(t,s)}case(t=>"Path"===t||"Path?"===t)(a):return e.arg((t=>{if(t.startsWith("/")){const n=t.slice(1).split("/");if(2!==n.length)throw Error("Incorrect Path - identifier missing");if(!g.includes(n[0]))throw Error("Incorrect Path - wrong domain");const[e,r]=n;return{domain:e,identifier:r}}throw Error("Incorrect Path - shall start with `/`")})(o),s);case O(a):{const t=W(a);if(C(t)){const n=await Promise.all(o.map(async n=>{const{value:e}=await X(t,n);return e}));return e.arg(n,s)}return e.arg(o,s)}case _(a):{const[t,n]=G(a),r=[],c=Object.keys(o);for(let e=0;e<c.length;e++){const a=c[e];let s;s=C(n)?(await X(n,o[a])).value:o[a];const i=M(t)?parseInt(a):a;r.push({key:i,value:s})}return e.arg(r,s)}default:throw`${a} is not supported`}var c},Y=async(t=[],n)=>{if(t.length>n.length)throw new Error("Not enough arguments");return Promise.all(n.map(async(n,e)=>{const r=await X(t[e],n);var o;return(o=r).xform.asArgument(o.value),r}))},Z=async(t,n=[])=>{const e=j(t).args.map(z);return Y(e,n)},tt=async(t,n)=>{if(0===t.length)return[];const r=t[0];return Array.isArray(r)&&r.length>0&&r[r.length-1].asArgument?(t=>t.reduce((t,n)=>[...t,...((t,n)=>{const r=t[t.length-1];return t.slice(0,-1).map(t=>((t,n)=>e.arg(t,n))(t,r))})(n)],[]))(t):Z(n,t)},nt=async(n,r)=>{const{code:o,cadence:a,args:c,addressMap:i,limit:u,processed:l}=n,f=o||a,d=D({},await s(),i),p=l?f:w(f,d),m="script"===r?[e.script(p)]:[e.transaction(p)];if(c){const t=await tt(c,o);m.push(e.args(t))}const g=await t().get("ix.executionLimit");if(m.push(e.limit(u||g||100)),"transaction"===r){const{proposer:t,payer:r,signers:o=[]}=n,a=0===o.length?[r]:o,s=t||r;m.push(e.payer(r)),m.push(e.proposer(s)),m.push(e.authorizations(a))}return e.send(m)},et=async t=>{const{raw:n=!1}=t;try{const r=await nt(t,"script");return n?[r.encodedData,null]:[await e.decode(r),null]}catch(t){return[null,t]}},rt=async t=>{const{wait:n="seal"}=t;try{const r=await nt(t,"transaction");if(n){const t=(t=>{if("string"==typeof t){const n=t.toLowerCase();if(n.includes("final"))return"onceFinalized";if(n.includes("exec"))return"onceExecuted";if(n.includes("seal"))return"onceSealed"}return console.log(`⚠️ [33mStatus value [1m[35m"${t}"[33m[2m is not supported. Reverting to [32m"onceSealed"[0m`),"onceSealed"})(n);return[D({txId:r},await e.tx(r)[t]()),null]}return[r.transactionId,null]}catch(t){return[null,t]}},ot=async t=>{const{name:n,to:e,payer:r,proposer:o,code:a,update:s=!1,processed:c=!1,addressMap:i={}}=t,u=c?a:w(a,i),l=s?"\n    transaction(name: String, code: String) {\n      prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        \n        acct.contracts.add(\n          name: name,\n          code: decoded,\n        )\n      }\n    }\n  ":"\n  transaction(name: String, code: String){\n    prepare(acct: AuthAccount){\n      let decoded = code.decodeHex()\n      \n      if acct.contracts.get(name: name) == nil {\n        acct.contracts.add(name: name, code: decoded)\n      } else {\n        acct.contracts.update__experimental(name: name, code: decoded)\n      }\n    }\n  }\n",f=Buffer.from(u,"utf8").toString("hex");let d=e,p=e;return r&&(p=r,d=o||r),rt({payer:p,proposer:d,signers:[e],code:l,args:[n,f]})},at=async t=>ot(D({},t,{update:!0}));export{$ as CONTRACT,R as PLUGIN_TYPES,k as SCRIPT,S as TRANSACTION,z as argType,y as capitalizeFirstLetter,v as collapseSpaces,ot as deployContract,et as executeScript,T as extract,N as extractContractName,U as extractContractParameters,l as extractImports,I as extractScriptArguments,P as extractSigners,A as extractTransactionArguments,E as generateSchema,W as getArrayType,G as getDictionaryTypes,s as getEnvironment,H as getPlugins,b as getSplitCharacter,j as getTemplateInfo,X as mapArgument,Y as mapArguments,Z as mapValuesToCode,f as missingImports,rt as mutate,et as query,B as registerPlugin,w as replaceImportAddresses,d as report,J as reportArguments,K as reportMissing,p as reportMissingImports,tt as resolveArguments,rt as sendTransaction,c as setEnvironment,q as splitArgs,h as trimAndSplit,x as underscoreToCamelCase,at as updateContract};
//# sourceMappingURL=main.modern.js.map
